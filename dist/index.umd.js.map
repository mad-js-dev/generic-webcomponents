{"version":3,"file":"index.umd.js","sources":["../src/components/molecules/collapsible-list/CollapsibleList.js","../src/components/atoms/collapsible-item/CollapsibleItem.js","../src/components/index.js","../src/wrappers/react/index.jsx","../src/wrappers/vue/index.js","../src/index.js","../src/components/organisms/selection-menu/SelectionMenu.js","../src/components/organisms/image-collection/ImageCollection.js","../src/components/templates/product-layout/ProductLayout.js"],"sourcesContent":["/**\n * CollapsibleList Component\n * A custom element that creates a collapsible list container\n */\n\nexport class CollapsibleList extends HTMLElement {\n  static get observedAttributes() {\n    return ['reverse-heading', 'single-item', 'accordion'];\n  }\n  \n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this._isUpdating = false; // Track if we're currently updating to prevent reentrant calls\n    this._handleItemToggle = this._handleItemToggle.bind(this);\n    \n    const container = document.createElement('div');\n    const slot = document.createElement('slot');\n    \n    // Create styles for the component\n    const style = document.createElement('style');\n    style.textContent = `\n      :host {\n        display: block;\n        width: 100%;\n        --indent-size: 1.5rem;\n      }\n      \n      ::slotted(collapsible-item) {\n        display: block;\n        margin: 0.25rem 0;\n        padding: 0;\n        width: 100%;\n      }\n      \n      /* Nested lists should have a border */\n      ::slotted(collapsible-list) {\n        border-left: 1px solid #e0e0e0;\n        margin-left: 0.5rem;\n        padding-left: 0.5rem;\n      }\n      \n      /* Style for the header in collapsible items */\n      .collapsible-item__header {\n        display: flex;\n        align-items: center;\n        width: 100%;\n        flex-direction: row;\n      }\n      \n      /* Toggle container styles */\n      .collapsible-item__toggle-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: var(--toggle-size, 24px);\n        height: var(--toggle-size, 24px);\n        margin: var(--toggle-margin, 0 8px 0 0);\n        flex-shrink: 0;\n      }`;\n    \n    container.appendChild(slot);\n    this.shadowRoot.append(style, container);\n  }\n  \n  async connectedCallback() {\n    if (!this._initialized) {\n      this._initializeComponent();\n      this._initialized = true;\n      \n      // Set initial reverse heading state\n      await this._updateReverseHeading();\n      \n      // Set up event listeners for accordion behavior\n      this.addEventListener('toggle', this._handleItemToggle);\n      \n      // Ensure at least one item is expanded in accordion mode\n      if (this.hasAttribute('accordion')) {\n        this._ensureOneItemExpanded();\n      }\n    }\n    \n    // Set up mutation observer for dynamic content\n    this._setupMutationObserver();\n  }\n  \n  _initializeComponent() {\n    if (!this.hasAttribute('role')) {\n      this.setAttribute('role', 'list');\n    }\n    \n    if (!this.hasAttribute('aria-label') && !this.hasAttribute('aria-labelledby')) {\n      console.warn('collapsible-list: Add an aria-label or aria-labelledby attribute for accessibility');\n    }\n  }\n  \n  _setupMutationObserver() {\n    // Set up a mutation observer to handle dynamically added items and attribute changes\n    this._observer = new MutationObserver(async (mutations) => {\n      let shouldUpdate = false;\n      \n      for (const mutation of mutations) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'reverse-heading') {\n          shouldUpdate = true;\n          break;\n        } else if (mutation.type === 'childList') {\n          // Check if any added nodes are collapsible items or lists\n          for (const node of mutation.addedNodes) {\n            if (node.nodeType === Node.ELEMENT_NODE && \n                (node.matches('collapsible-item') || node.matches('collapsible-list'))) {\n              shouldUpdate = true;\n              break;\n            }\n          }\n          if (shouldUpdate) break;\n        }\n      }\n      \n      if (shouldUpdate) {\n        await this._updateReverseHeading();\n      }\n    });\n    \n    // Start observing the component for attribute changes and child list changes\n    this._observer.observe(this, {\n      attributes: true,\n      attributeFilter: ['reverse-heading'],\n      childList: true,\n      subtree: true\n    });\n  }\n  \n  /**\n   * Updates the reverse heading state for all child collapsible items\n   * @private\n   */\n  async _updateReverseHeading() {\n    // Prevent reentrant calls\n    if (this._isUpdating) return;\n    this._isUpdating = true;\n    \n    try {\n      const isReversed = this.hasAttribute('reverse-heading') && \n                       this.getAttribute('reverse-heading') !== 'false';\n      \n      // Temporarily disconnect observer to prevent infinite loop\n      if (this._observer) {\n        this._observer.disconnect();\n      }\n      \n      // Process direct child collapsible-items\n      const processItems = async (items) => {\n        for (const item of items) {\n          // Set the attribute on the item\n          if (isReversed) {\n            item.setAttribute('reverse-heading', '');\n          } else {\n            item.removeAttribute('reverse-heading');\n          }\n          \n          // Process any nested items in this item (only direct children)\n          const nestedItems = item.querySelectorAll(':scope > collapsible-item');\n          if (nestedItems.length > 0) {\n            await processItems(Array.from(nestedItems));\n          }\n          \n          // Process any nested lists in this item (only direct children)\n          const nestedLists = item.querySelectorAll(':scope > collapsible-list');\n          if (nestedLists.length > 0) {\n            await processLists(Array.from(nestedLists));\n          }\n        }\n      };\n      \n      // Process nested collapsible-lists\n      const processLists = async (lists) => {\n        for (const list of lists) {\n          // Skip if this is the current list to prevent cycles\n          if (list === this) continue;\n          \n          // Set the attribute on the list\n          if (isReversed) {\n            list.setAttribute('reverse-heading', '');\n          } else {\n            list.removeAttribute('reverse-heading');\n          }\n          \n          // Process any direct child items in this list\n          const nestedItems = list.querySelectorAll(':scope > collapsible-item');\n          if (nestedItems.length > 0) {\n            await processItems(Array.from(nestedItems));\n          }\n          \n          // Process any direct child lists\n          const nestedLists = list.querySelectorAll(':scope > collapsible-list');\n          if (nestedLists.length > 0) {\n            await processLists(Array.from(nestedLists));\n          }\n        }\n      };\n      \n      // Start processing from the current element\n      const items = this.querySelectorAll(':scope > collapsible-item');\n      if (items.length > 0) {\n        await processItems(Array.from(items));\n      }\n      \n      const lists = this.querySelectorAll(':scope > collapsible-list');\n      if (lists.length > 0) {\n        await processLists(Array.from(lists));\n      }\n      \n      // Force a reflow to ensure all attribute changes are applied\n      if (this.shadowRoot) {\n        this.shadowRoot.offsetHeight; // This forces a reflow\n      }\n    } catch (error) {\n      console.error('Error updating reverse heading:', error);\n    } finally {\n      // Reconnect observer if it exists\n      if (this._observer) {\n        this._observer.observe(this, {\n          attributes: true,\n          attributeFilter: ['reverse-heading'],\n          childList: true,\n          subtree: true\n        });\n      }\n      this._isUpdating = false;\n    }\n  }\n\n  _handleItemToggle(e) {\n    if (this._isUpdating) return;\n    \n    const target = e.target;\n    \n    // Only process if this is a direct child\n    if (target.parentElement === this) {\n      this._isUpdating = true;\n      \n      if (this.hasAttribute('accordion')) {\n        // In accordion mode, close other items when one is opened\n        if (target.expanded) {\n          this._closeOtherItems(target);\n        }\n      } else if (this.hasAttribute('single-item')) {\n        // In single-item mode, just close other items when one is opened\n        if (target.expanded) {\n          this._closeOtherItems(target);\n        }\n      }\n      \n      this._isUpdating = false;\n    }\n  }\n  \n  _closeOtherItems(exceptItem) {\n    // Don't close items if inside an image-collection\n    if (this.closest('image-collection')) {\n      return;\n    }\n    \n    const items = this.querySelectorAll('collapsible-item');\n    items.forEach(item => {\n      if (item !== exceptItem) {\n        item.expanded = false;\n      }\n    });\n  }\n  \n  _getOpenItems() {\n    return Array.from(this.querySelectorAll('collapsible-item[expanded]'));\n  }\n  \n  _ensureOneItemExpanded() {\n    if (!this.hasAttribute('accordion')) return;\n    \n    const openItems = this._getOpenItems();\n    if (openItems.length === 0) {\n      // If no items are open, open the first one\n      const firstItem = this.querySelector('collapsible-item');\n      if (firstItem) {\n        firstItem.setAttribute('expanded', '');\n      }\n    }\n  }\n}\n\n// Define the custom element\nif (!customElements.get('collapsible-list')) {\n  customElements.define('collapsible-list', CollapsibleList);\n}\n","/**\n * CollapsibleItem Component\n * A custom element that creates a collapsible list item\n */\n\nexport class CollapsibleItem extends HTMLElement {\n  static get observedAttributes() {\n    return ['expanded', 'reverse-heading', 'hide-icon'];\n  }\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this._isExpanded = false;\n    this._nestedList = null;\n    this._showToggle = false;\n    this._initialized = false;\n    \n    // Bind methods\n    this._handleHeaderClick = this._handleHeaderClick.bind(this);\n    this._handleKeyDown = this._handleKeyDown.bind(this);\n  }\n\n  connectedCallback() {\n    // Only initialize once\n    if (!this._initialized) {\n      this._initializeComponent();\n      this._initialized = true;\n      \n      // Set initial expanded state after component is initialized\n      const isExpanded = this.hasAttribute('expanded');\n      this._isExpanded = isExpanded;\n      \n      // Update the DOM\n      if (this._nestedContent) {\n        this._nestedContent.style.display = isExpanded ? 'block' : 'none';\n      }\n    }\n    \n    // Update styles and attributes immediately after initialization\n    this._updateToggleVisibility();\n    this._updateReverseHeading();\n    this._updateAriaExpanded();\n    \n    // Update toggle state based on expanded status\n    if (this._toggleElement) {\n      if (this.expanded) {\n        this._toggleElement.classList.add('collapsible-item__toggle--expanded');\n      } else {\n        this._toggleElement.classList.remove('collapsible-item__toggle--expanded');\n      }\n    }\n  }\n\n  _initializeComponent() {\n    // Clear any existing content\n    if (this.shadowRoot) {\n      this.shadowRoot.innerHTML = '';\n    } else {\n      this.attachShadow({ mode: 'open' });\n    }\n    \n    // Create the main container\n    const content = document.createElement('div');\n    content.className = 'collapsible-item';\n    \n    // Create the header element\n    this._headerElement = document.createElement('div');\n    this._headerElement.className = 'collapsible-item__header';\n    this._headerElement.setAttribute('part', 'header'); // Expose header as a part\n    \n    // Only create toggle if hide-icon is not true\n    let toggleContainer = null;\n    if (!this.hasAttribute('hide-icon')) {\n      toggleContainer = document.createElement('div');\n      toggleContainer.className = 'collapsible-item__toggle-container';\n      \n      // Create the toggle button\n      this._toggleElement = document.createElement('button');\n      this._toggleElement.className = 'collapsible-item__toggle';\n      this._toggleElement.setAttribute('aria-label', 'Toggle visibility');\n      this._toggleElement.setAttribute('aria-expanded', 'false');\n      this._toggleElement.innerHTML = '▼';\n      \n      // Add toggle to its container\n      toggleContainer.appendChild(this._toggleElement);\n    }\n    \n    // Create a slot for the header content\n    this._headerSlot = document.createElement('slot');\n    this._headerSlot.name = 'header';\n    \n    // Create a container for the header content\n    const headerContent = document.createElement('div');\n    headerContent.className = 'collapsible-item__content';\n    headerContent.appendChild(this._headerSlot);\n    \n    // Only append toggle container if it exists\n    if (toggleContainer) {\n      this._headerElement.appendChild(toggleContainer);\n    }\n    this._headerElement.appendChild(headerContent);\n    \n    // Create a default slot for nested content\n    this._defaultSlot = document.createElement('slot');\n    \n    // Create the nested content container\n    this._nestedContent = document.createElement('div');\n    this._nestedContent.className = 'collapsible-item__nested';\n    this._nestedContent.style.display = 'none'; // Start collapsed by default\n    this._nestedContent.appendChild(this._defaultSlot);\n    \n    // Add click event to the header and toggle button\n    this._headerElement.addEventListener('click', this._handleHeaderClick);\n    this._headerElement.addEventListener('keydown', this._handleKeyDown);\n    \n    // Add click handler specifically for the toggle button\n    if (this._toggleElement) {\n      this._toggleElement.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.toggle();\n      });\n    }\n    \n    // Build the DOM structure\n    content.appendChild(this._headerElement);\n    content.appendChild(this._nestedContent);\n    \n    // Add styles\n    const style = document.createElement('style');\n    style.textContent = `\n      :host {\n        display: block;\n        margin: 0;\n        padding: 0;\n      }\n\n      .collapsible-item {\n          display: flex;\n          flex-direction: column;\n          width: 100%;\n      }\n      \n      .collapsible-item__header {\n        display: flex;\n        align-items: center;\n        width: 100%;\n        margin: 0;\n        padding: 0;\n        background: none;\n        border: none;\n        font: inherit;\n        color: inherit;\n        cursor: pointer;\n      }\n      \n      .collapsible-item__toggle-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: 24px;\n        height: 24px;\n        flex-shrink: 0;\n        margin-right: 8px;\n        \n      }\n      \n      .collapsible-item__toggle {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: 100%;\n        height: 100%;\n        margin: 0;\n        padding: 0;\n        background: none;\n        border: none;\n        cursor: pointer;\n        transition: transform 0.2s ease-in-out;\n        font-size: 0.8em;\n        line-height: 1;\n        color: inherit;\n      }\n      \n      .collapsible-item__toggle--hidden {\n        visibility: hidden;\n        width: 0;\n        margin: 0;\n      }\n      \n      .collapsible-item__toggle--expanded {\n        transform: rotate(180deg);\n      }\n      \n      .collapsible-item__content {\n        flex: 1 1 auto;\n        min-width: 0; /* Allows content to shrink below its minimum content size */\n        text-align: left;\n        margin: 0;\n        padding: 0;\n        overflow: hidden; /* Ensures content doesn't overflow */\n        display: flex;\n        align-items: center;\n      }\n      \n      .collapsible-item__content ::slotted(*) {\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis; /* Add ellipsis for overflow text */\n        text-overflow: ellipsis;\n      }\n      \n      .collapsible-item__nested {\n        margin: 0;\n        padding: 0;\n        display: block;\n        overflow: hidden;\n      }\n      collapsible-item > collapsible-list {\n        padding-left: 1rem;\n      }\n    `;\n    \n    // Append everything to the shadow root\n    this.shadowRoot.append(style, content);\n  }\n  \n  _handleHeaderClick(event) {\n    // Don't toggle if the click was on a link, button, or input\n    const interactiveElements = ['a', 'button', 'input', 'select', 'textarea'];\n    if (event.target.closest(interactiveElements.join(','))) {\n      return;\n    }\n    \n    // Always allow toggling on header click, regardless of _showToggle\n    // This makes the entire header clickable\n    event.preventDefault();\n    event.stopPropagation();\n    this.toggle();\n  }\n  \n  _handleKeyDown(event) {\n    if (event.key === 'Enter' || event.key === ' ') {\n      event.preventDefault();\n      this.toggle();\n    }\n  }\n  \n  _updateToggleVisibility() {\n    if (!this._headerElement) return;\n    \n    const headerContent = this.shadowRoot.querySelector('.collapsible-item__content');\n    const isNoChildren = this.hasAttribute('no-children');\n    \n    // Handle toggle container and icon visibility\n    if (this.hasAttribute('hide-icon') || isNoChildren) {\n      this._showToggle = false;\n      \n      // Hide the toggle element if it exists\n      if (this._toggleElement) {\n        this._toggleElement.style.display = 'none';\n      }\n      \n      // Adjust header content to take full width\n      if (headerContent) {\n        headerContent.style.marginLeft = '0';\n        headerContent.style.paddingLeft = '0';\n      }\n      \n      // Adjust header styles\n      this._headerElement.style.paddingLeft = '0';\n      this._headerElement.style.marginLeft = '0';\n      \n      return;\n    }\n    \n    // Show toggle if there's nested content\n    const hasNestedItems = this._nestedContent && this._nestedContent.children.length > 0;\n    this._showToggle = hasNestedItems;\n    \n    if (this._toggleElement) {\n      this._toggleElement.style.display = this._showToggle ? 'inline-block' : 'none';\n      \n      // Update toggle rotation based on expanded state\n      if (this.expanded) {\n        this._toggleElement.classList.add('collapsible-item__toggle--expanded');\n      } else {\n        this._toggleElement.classList.remove('collapsible-item__toggle--expanded');\n      }\n    }\n    \n    if (this._showToggle && this._headerElement) {\n      this._headerElement.setAttribute('role', 'button');\n      this._headerElement.setAttribute('tabindex', '0');\n      this._headerElement.setAttribute('aria-expanded', this.expanded.toString());\n      this._headerElement.classList.add('collapsible-item__header--clickable');\n      \n      // Update toggle class based on expanded state\n      if (this.expanded) {\n        this._toggleElement.classList.add('collapsible-item__toggle--expanded');\n      } else {\n        this._toggleElement.classList.remove('collapsible-item__toggle--expanded');\n      }\n    } else {\n      this._toggleElement.style.display = 'none';\n      this._toggleElement.classList.add('collapsible-item__toggle--hidden');\n      \n      // Remove ARIA attributes when toggle is hidden\n      this._headerElement.removeAttribute('role');\n      this._headerElement.removeAttribute('tabindex');\n      this._headerElement.removeAttribute('aria-expanded');\n      this._headerElement.classList.remove('collapsible-item__header--clickable');\n    }\n  }\n  \n  get expanded() {\n    return this._isExpanded;\n  }\n\n  set expanded(value) {\n    const isExpanded = Boolean(value);\n    if (this._isExpanded === isExpanded) return;\n    \n    this._isExpanded = isExpanded;\n    \n    // Update the DOM\n    if (this._nestedContent) {\n      if (isExpanded) {\n        this._nestedContent.style.display = 'block';\n        this._nestedContent.style.overflow = 'hidden';\n        this._nestedContent.style.height = 'auto';\n        \n        // Animate the height\n        const startHeight = this._nestedContent.offsetHeight;\n        this._nestedContent.style.height = '0';\n        \n        requestAnimationFrame(() => {\n          this._nestedContent.style.transition = 'height 0.3s ease-in-out';\n          this._nestedContent.style.height = `${startHeight}px`;\n          \n          // Remove the transition after animation completes\n          setTimeout(() => {\n            this._nestedContent.style.transition = '';\n            this._nestedContent.style.height = '';\n            this._nestedContent.style.overflow = '';\n          }, 300);\n        });\n      } else {\n        // Collapse with animation\n        const startHeight = this._nestedContent.offsetHeight;\n        this._nestedContent.style.height = `${startHeight}px`;\n        this._nestedContent.style.overflow = 'hidden';\n        \n        requestAnimationFrame(() => {\n          this._nestedContent.style.transition = 'height 0.3s ease-in-out';\n          this._nestedContent.style.height = '0';\n          \n          // After collapse, set display to none\n          setTimeout(() => {\n            if (this._nestedContent) {\n              this._nestedContent.style.display = 'none';\n              this._nestedContent.style.transition = '';\n              this._nestedContent.style.height = '';\n            }\n          }, 300);\n        });\n      }\n    }\n    \n    // Update header classes and ARIA attributes\n    if (this._headerElement) {\n      if (isExpanded) {\n        this._headerElement.classList.add('collapsible-item__header--expanded');\n      } else {\n        this._headerElement.classList.remove('collapsible-item__header--expanded');\n      }\n      \n      // Update ARIA attributes when expanded state changes\n      if (this._showToggle) {\n        this._headerElement.setAttribute('aria-expanded', isExpanded.toString());\n      }\n    }\n    \n    // Update toggle element\n    if (this._toggleElement) {\n      if (isExpanded) {\n        this._toggleElement.classList.add('collapsible-item__toggle--expanded');\n      } else {\n        this._toggleElement.classList.remove('collapsible-item__toggle--expanded');\n      }\n    }\n    \n    // Dispatch events\n    this._dispatchEvents(isExpanded);\n  }\n  \n  toggle(force) {\n    const shouldExpand = force !== undefined ? force : !this.expanded;\n    \n    // Update the expanded state\n    this.expanded = shouldExpand;\n    \n    // Update ARIA and classes\n    this._updateAriaExpanded();\n    \n    // Update toggle icon\n    if (this._toggleElement) {\n      if (shouldExpand) {\n        this._toggleElement.classList.add('collapsible-item__toggle--expanded');\n      } else {\n        this._toggleElement.classList.remove('collapsible-item__toggle--expanded');\n      }\n    }\n    \n    // Dispatch the change event\n    this._dispatchEvents(shouldExpand);\n  }\n  \n  _dispatchEvents(isExpanded) {\n    // Dispatch toggle event\n    this.dispatchEvent(new CustomEvent('toggle', {\n      detail: { expanded: isExpanded },\n      bubbles: true,\n      composed: true\n    }));\n    \n    // Also dispatch expanded/collapsed events\n    const eventType = isExpanded ? 'expanded' : 'collapsed';\n    this.dispatchEvent(new CustomEvent(eventType, {\n      bubbles: true,\n      composed: true\n    }));\n  }\n  \n  _updateAriaExpanded() {\n    if (this._headerElement) {\n      this._headerElement.setAttribute('aria-expanded', this._isExpanded.toString());\n    }\n  }\n  \n  _updateReverseHeading() {\n    const isReversed = this.hasAttribute('reverse-heading') && \n                     this.getAttribute('reverse-heading') !== 'false';\n    \n    const header = this.shadowRoot?.querySelector('.collapsible-item__header');\n    const toggle = this.shadowRoot?.querySelector('.collapsible-item__toggle-container');\n    \n    if (header && toggle) {\n      if (isReversed) {\n        header.style.flexDirection = 'row-reverse';\n        toggle.style.margin = '0 0 0 8px';\n      } else {\n        header.style.flexDirection = 'row';\n        toggle.style.margin = '0 8px 0 0';\n      }\n    }\n  }\n  \n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === 'expanded' && oldValue !== newValue) {\n      this.expanded = newValue !== null;\n      this._updateAriaExpanded();\n    } else if (name === 'reverse-heading') {\n      this._updateReverseHeading();\n    }\n  }\n}\n\n// Define the custom element\nif (!customElements.get('collapsible-item')) {\n  customElements.define('collapsible-item', CollapsibleItem);\n}\n","// Core components\nexport * from './molecules/collapsible-list/CollapsibleList.js';\nexport * from './atoms/collapsible-item/CollapsibleItem.js';\n\n// Additional components (dynamically imported when needed)\nlet additionalComponents = {};\n\n// Function to load additional components\nexport async function loadAdditionalComponents() {\n  try {\n    const selectionMenuModule = await import('./organisms/selection-menu/SelectionMenu.js');\n    additionalComponents.SelectionMenu = selectionMenuModule.default || selectionMenuModule;\n  } catch (e) {\n    console.warn('SelectionMenu component not found or failed to load', e);\n  }\n\n  try {\n    const productLayoutModule = await import('./templates/product-layout/ProductLayout.js');\n    additionalComponents.ProductLayout = productLayoutModule.default || productLayoutModule;\n  } catch (e) {\n    console.warn('ProductLayout component not found or failed to load', e);\n  }\n  \n  return additionalComponents;\n}\n\n// Export a function to get additional components\nexport function getAdditionalComponents() {\n  return additionalComponents;\n}\n","import { useEffect, useRef, forwardRef } from 'react';\nimport * as webComponents from '../../components';\n\n// Auto-generate React wrappers for all web components\nconst wrappers = {};\n\nObject.entries(webComponents).forEach(([componentName, webComponent]) => {\n  if (typeof webComponent === 'function' && webComponent.name) {\n    const ReactComponent = forwardRef(({ children, ...props }, ref) => {\n      const elementRef = useRef(null);\n      const eventHandlers = useRef({});\n\n      // Handle event listeners\n      useEffect(() => {\n        const element = elementRef.current;\n        const currentEventHandlers = {};\n\n        // Add event listeners\n        Object.entries(props).forEach(([key, value]) => {\n          if (typeof value === 'function' && key.startsWith('on')) {\n            const eventName = key.substring(2).toLowerCase();\n            const handler = (e) => {\n              // Forward the event to the React event handler\n              value(e);\n            };\n            element.addEventListener(eventName, handler);\n            currentEventHandlers[eventName] = handler;\n          }\n        });\n\n        // Store current event handlers for cleanup\n        eventHandlers.current = currentEventHandlers;\n\n        // Cleanup event listeners\n        return () => {\n          Object.entries(eventHandlers.current).forEach(([eventName, handler]) => {\n            element.removeEventListener(eventName, handler);\n          });\n        };\n      }, [props]);\n\n      // Filter out event handlers from props to avoid React warnings\n      const elementProps = Object.entries(props).reduce((acc, [key, value]) => {\n        if (!(typeof value === 'function' && key.startsWith('on'))) {\n          acc[key] = value;\n        }\n        return acc;\n      }, {});\n\n      // Forward the ref\n      useEffect(() => {\n        if (ref) {\n          if (typeof ref === 'function') {\n            ref(elementRef.current);\n          } else {\n            ref.current = elementRef.current;\n          }\n        }\n      }, [ref]);\n\n      const TagName = webComponent.is || componentName.toLowerCase();\n      \n      return (\n        <TagName ref={elementRef} {...elementProps}>\n          {children}\n        </TagName>\n      );\n    });\n\n    // Set display name for better debugging\n    ReactComponent.displayName = componentName;\n    wrappers[componentName] = ReactComponent;\n  }\n});\n\nexport default wrappers;\n","import * as webComponents from '../../components';\n\nconst VuePlugin = {\n  install(app) {\n    // Register all web components as Vue components\n    Object.entries(webComponents).forEach(([componentName, webComponent]) => {\n      if (typeof webComponent === 'function' && webComponent.name) {\n        const tagName = webComponent.is || componentName.toLowerCase();\n        \n        // Create a Vue component definition\n        const vueComponent = {\n          name: componentName,\n          inheritAttrs: false,\n          emits: [], // Will be populated with event names\n          props: {},\n          render() {\n            // Convert kebab-case attributes to camelCase for web components\n            const attrs = Object.entries(this.$attrs).reduce((acc, [key, value]) => {\n              // Convert kebab-case to camelCase for props\n              const camelKey = key.replace(/-([a-z])/g, (g) => g[1].toUpperCase());\n              acc[camelKey] = value;\n              return acc;\n            }, {});\n\n            // Add event listeners\n            const on = {};\n            Object.keys(this.$listeners).forEach((event) => {\n              on[event] = this.$listeners[event];\n            });\n\n            return this.$createElement(\n              tagName,\n              {\n                attrs,\n                on,\n                ref: 'webComponent',\n              },\n              this.$slots.default\n            );\n          },\n        };\n\n        // Register the component globally\n        app.component(componentName, vueComponent);\n      }\n    });\n  },\n};\n\nexport default VuePlugin;\n","// Core web components\nexport * from './components';\n\n// Additional components that need to be loaded asynchronously\nimport { loadAdditionalComponents, getAdditionalComponents } from './components';\n\n// Export React wrappers\nexport { default as ReactWrappers } from './wrappers/react/index.jsx';\n\n// Export Vue plugin\nexport { default as VuePlugin } from './wrappers/vue';\n\n// Export component loader\nexport const Components = {\n  // Core components are already available via default export\n  ...getAdditionalComponents(),\n  \n  // Method to load additional components\n  async load() {\n    await loadAdditionalComponents();\n    Object.assign(this, getAdditionalComponents());\n    return this;\n  }\n};\n\n// Auto-load additional components in browser environment\nif (typeof window !== 'undefined') {\n  Components.load().catch(console.error);\n}\n","/**\n * SelectionMenu Component\n * A custom element that creates a selectable menu using collapsible-list components\n */\n\nexport class SelectionMenu extends HTMLElement {\n  static get observedAttributes() {\n    return ['value', 'data', 'block-events-on-parent', 'reverse-heading'];\n  }\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this._selectedId = null;\n    this._data = [];\n    this._blockEventsOnParent = false;\n    this._reverseHeading = true;\n  }\n\n  connectedCallback() {\n    this.render();\n    this.setupEventListeners();\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (oldValue === newValue) return;\n\n    switch (name) {\n      case 'data':\n        this.data = newValue ? JSON.parse(newValue) : [];\n        break;\n      case 'value':\n        this.setSelectedItem(newValue);\n        break;\n      case 'block-events-on-parent':\n        this.blockEventsOnParent = newValue !== null;\n        break;\n      case 'reverse-heading':\n        this.reverseHeading = newValue !== 'false';\n        break;\n    }\n  }\n\n  render() {\n    // Clear the shadow root\n    this.shadowRoot.innerHTML = '';\n    \n    // Create and append style element\n    const style = document.createElement('style');\n    style.textContent = `\n      :host {\n        display: block;\n        --primary-color: #4a6cf7;\n        --primary-light: #e6f0ff;\n        --hover-color: #f5f8ff;\n        --selected-color: #e6f0ff;\n        --text-color: #2d3748;\n        --text-secondary: #4a5568;\n        --border-color: #e2e8f0;\n        --border-radius: 4px;\n        --transition: all 0.2s ease;\n      }\n      \n      .selection-menu {\n        flex: 1;\n        display: flex;\n        flex-direction: column;\n        overflow: hidden;\n        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n      }\n      \n      .selection-menu__header {\n        padding: 12px 16px;\n        border-bottom: 1px solid var(--border-color);\n        font-weight: 600;\n        color: var(--text-color);\n      }\n      \n      .selection-menu__container {\n        flex: 1;\n        padding: 8px 0;\n        overflow-y: auto;\n      }\n      \n      .selection-menu__item {\n        display: flex;\n        align-items: center;\n        box-sizing: border-box;\n        padding: 8px 0;\n        cursor: pointer;\n      }\n      \n      \n      .selection-menu__item--selected {\n        background-color: var(--selected-color);\n        color: var(--primary-color);\n        font-weight: 500;\n      }\n      \n      .selection-menu__item--level-1 {\n        padding-left: 32px;\n      }\n      \n      .selection-menu__item--level-2 {\n        padding-left: 48px;\n      }\n      \n      .selection-menu__item--level-3 {\n        padding-left: 64px;\n      }\n    `;\n    \n    // Create the main container\n    const container = document.createElement('div');\n    container.className = 'selection-menu';\n    container.innerHTML = `\n      <div class=\"selection-menu__wrapper\">\n        <div class=\"selection-menu__container\">\n          <collapsible-list id=\"menuList\" class=\"selection-menu__list\" aria-label=\"Menu\" reverse-heading=\"${this._reverseHeading}\">\n            ${this.renderItems(this._data)}\n          </collapsible-list>\n        </div>\n      </div>\n    `;\n    \n    // Append style and container to shadow root\n    this.shadowRoot.appendChild(style);\n    this.shadowRoot.appendChild(container);\n    \n    // Set up event listeners after the DOM is ready\n    this.setupEventListeners();\n  }\n  \n  renderItems(items, level = 0) {\n    return items.map(item => {\n      const hasChildren = item.children && item.children.length > 0;\n      const isSelected = this._selectedId === item.id;\n      \n      return `\n        <collapsible-item \n          class=\"selection-menu__item selection-menu__item--level-${level}\"\n          value=\"${item.id}\" \n          data-id=\"${item.id}\" \n          level=\"${level}\" \n          ${!hasChildren ? 'no-children hide-icon' : ''} \n          reverse-heading=\"${this._reverseHeading}\"\n          ${isSelected ? 'selected' : ''}\n        >\n          <span slot=\"header\" class=\"selection-menu__item-header ${isSelected ? 'selection-menu__item-header--selected' : ''}\">\n            ${item.name}\n          </span>\n          ${hasChildren ? `\n            <collapsible-list class=\"selection-menu__list\">\n              ${this.renderItems(item.children, level + 1)}\n            </collapsible-list>\n          ` : ''}\n        </collapsible-item>\n      `;\n    }).join('');\n  }\n  \n  setupEventListeners() {\n    const menuList = this.shadowRoot.getElementById('menuList');\n    \n    if (!menuList) {\n      console.error('menuList element not found in shadow DOM');\n      return;\n    }\n    \n    // Store the bound function so we can remove it later\n    this._boundHandleClick = this.handleItemClick.bind(this);\n    \n    // Add click listener with capture phase to catch all clicks\n    menuList.addEventListener('click', this._boundHandleClick, true);\n  }\n  \n  handleItemClick(event) {\n    // Check if the click is on a collapsible-item or its children\n    const item = event.target.closest('collapsible-item');\n    \n    if (!item) {\n      return;\n    }\n    \n    const itemId = item.getAttribute('data-id');\n    \n    if (!itemId) {\n      return;\n    }\n    \n    // Find the item data to check if it's a leaf node\n    const itemData = this._findItemById(this._data, itemId);\n    \n    // Only proceed if this is a leaf node (no children)\n    if (itemData && itemData.children && itemData.children.length > 0) {\n      return;\n    }\n    \n    this.setSelectedItem(itemId);\n    \n    // Create and dispatch the custom event for leaf items only\n    const customEvent = new CustomEvent('item-selected', {\n      detail: { \n        id: itemId,\n        item: itemData\n      },\n      bubbles: true,\n      composed: true\n    });\n    \n    this.dispatchEvent(customEvent);\n    \n    // Dispatch to window as a fallback\n    window.dispatchEvent(new CustomEvent('global-item-selected', {\n      detail: { \n        id: itemId,\n        item: itemData\n      }\n    }));\n  }\n  \n  // Helper method to find an item by ID in nested data\n  _findItemById(items, id) {\n    for (const item of items) {\n      if (item.id === id) return item;\n      if (item.children) {\n        const found = this._findItemById(item.children, id);\n        if (found) return found;\n      }\n    }\n    return null;\n  }\n  \n  // Public method to set the selected item by ID\n  setSelectedItem(id) {\n    if (id === this._selectedId) return false;\n    \n    // Remove selected class from previously selected item\n    if (this._selectedId) {\n      const prevSelected = this.shadowRoot.querySelector(`collapsible-item[data-id=\"${this._selectedId}\"]`);\n      if (prevSelected) {\n        prevSelected.removeAttribute('selected');\n      }\n    }\n    \n    // Set new selected item\n    this._selectedId = id;\n    \n    // Add selected class to new item\n    const newSelected = this.shadowRoot.querySelector(`collapsible-item[data-id=\"${id}\"]`);\n    if (newSelected) {\n      newSelected.setAttribute('selected', '');\n    }\n    \n    // Update the value attribute\n    if (id) {\n      this.setAttribute('value', id);\n    } else {\n      this.removeAttribute('value');\n    }\n    \n    return true;\n  }\n  \n  // Getter/setter for data property\n  get data() {\n    return this._data;\n  }\n  \n  set data(value) {\n    if (Array.isArray(value)) {\n      this._data = value;\n      this.render();\n    } else if (typeof value === 'string') {\n      try {\n        this._data = JSON.parse(value);\n        this.render();\n      } catch (e) {\n        console.error('Invalid data format for selection-menu', e);\n      }\n    }\n  }\n  \n  // Getter/setter for blockEventsOnParent property\n  get blockEventsOnParent() {\n    return this._blockEventsOnParent;\n  }\n  \n  set blockEventsOnParent(value) {\n    if (value !== undefined) {\n      this._blockEventsOnParent = value;\n      this.setAttribute('block-events-on-parent', value ? '' : null);\n    }\n    return this._blockEventsOnParent;\n  }\n\n  // Getter/setter for reverseHeading property\n  get reverseHeading() {\n    return this._reverseHeading;\n  }\n\n  set reverseHeading(value) {\n    const newValue = value !== false && value !== 'false' && value !== null;\n    if (this._reverseHeading !== newValue) {\n      this._reverseHeading = newValue;\n      this.setAttribute('reverse-heading', newValue ? '' : null);\n      this.render();\n    }\n    \n    // Create style element\n    const style = document.createElement('style');\n    style.textContent = `\n      :host {\n        display: block;\n        width: 100%;\n      }\n      \n      #menuList {\n        list-style: none;\n        margin: 0;\n        padding: 0;\n      }\n    `;\n    \n    // Create menu list container\n    const menuList = document.createElement('div');\n    menuList.id = 'menuList';\n    \n    // Clear shadow root and append new elements\n    this.shadowRoot.innerHTML = '';\n    this.shadowRoot.appendChild(style);\n    this.shadowRoot.appendChild(menuList);\n    \n    // Update the menu list content\n    menuList.innerHTML = this.renderItems(this._data);\n    \n    // Re-setup event listeners after render\n    this.setupEventListeners();\n  }\n}\n\n// Define the custom element\nif (!customElements.get('selection-menu')) {\n  customElements.define('selection-menu', SelectionMenu);\n}\n","/**\n * ImageCollection Component\n * A custom element that displays a collection of images in a collapsible list\n */\n\nexport class ImageCollection extends HTMLElement {\n  static get observedAttributes() {\n    return ['images', 'no-animation'];\n  }\n  \n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this._images = [];\n    this._hasRendered = false;\n    this._handleItemClick = this._handleItemClick.bind(this);\n    this._handleKeyDown = this._handleKeyDown.bind(this);\n    this._handleToggle = this._handleToggle.bind(this);\n    this._currentOpenItem = null;\n    this._initialized = false;\n    this._lastOpenedIndex = -1;\n    this._mutationObserver = null;\n    this._intersectionObserver = null;\n    this._preloadedImages = new Map(); // Cache for preloaded images\n    this._visibleIndices = new Set(); // Track visible items\n    this._preloadDistance = 2; // Number of items to preload around visible ones\n    this._isInitialLoad = true; // Track if this is the first load\n  }\n  \n  get images() {\n    return this._images;\n  }\n  \n  set images(value) {\n    if (Array.isArray(value)) {\n      this._images = value;\n      this._preloadImages(); // Preload when images are set\n      this._render();\n    } else if (typeof value === 'string') {\n      try {\n        this._images = JSON.parse(value);\n        this._preloadImages(); // Preload when images are set via string\n        this._render();\n      } catch (e) {\n        console.error('Invalid images data format', e);\n      }\n    }\n  }\n  \n  connectedCallback() {\n    if (!this._initialized) {\n      this._initialized = true;\n      let isInitialRender = true;\n      this._render();\n      \n      // After the first render, set up the initial load state\n      if (isInitialRender) {\n        this._isInitialLoad = true;\n        // Set initial height for all containers\n        const containers = this.shadowRoot.querySelectorAll('.image-container');\n        containers.forEach(container => {\n          container.style.height = '300px';\n        });\n        \n        // Add initial load class for first render if not using no-animation\n        if (!this.hasAttribute('no-animation')) {\n          this.classList.add('initial-load');\n        } else {\n          // If no-animation is set, ensure images are immediately visible\n          const images = this.shadowRoot.querySelectorAll('.image-collection__image');\n          images.forEach(img => img.classList.add('loaded'));\n        }\n      }\n      \n      // Add event listeners after initial render\n      this._addEventListeners();\n      \n      // Set up mutation observer\n      this._setupMutationObserver();\n      \n      // Preload all images immediately\n      this.preloadAllImages();\n      \n      // Set the first item as expanded by default if none is expanded\n      if (!this._hasExpandedItem()) {\n        this._setFirstItemExpanded();\n      }\n    }\n  }\n  \n  _addEventListeners() {\n    // Handle toggle events from collapsible items\n    this.addEventListener('toggle', (e) => {\n      // Only handle events from direct children\n      const item = e.target;\n      if (item.parentElement !== this.shadowRoot.querySelector('collapsible-list')) {\n        return;\n      }\n      \n      // If an item is being expanded, close all others\n      if (e.detail.expanded) {\n        this._closeOtherItems(item);\n        \n        // Dispatch a custom event\n        const items = Array.from(this.shadowRoot.querySelectorAll('collapsible-item'));\n        this.dispatchEvent(new CustomEvent('item-selected', {\n          detail: { \n            index: items.indexOf(item),\n            item: item\n          },\n          bubbles: true,\n          composed: true\n        }));\n      }\n    });\n    \n    // Handle keyboard navigation\n    this.addEventListener('keydown', (e) => {\n      const items = Array.from(this.shadowRoot.querySelectorAll('collapsible-item'));\n      const currentIndex = items.findIndex(item => item === document.activeElement.closest('collapsible-item'));\n      \n      if (currentIndex === -1) return;\n      \n      switch (e.key) {\n        case 'ArrowDown':\n          e.preventDefault();\n          const nextIndex = (currentIndex + 1) % items.length;\n          items[nextIndex].focus();\n          break;\n          \n        case 'ArrowUp':\n          e.preventDefault();\n          const prevIndex = (currentIndex - 1 + items.length) % items.length;\n          items[prevIndex].focus();\n          break;\n          \n        case 'Home':\n          e.preventDefault();\n          items[0].focus();\n          break;\n          \n        case 'End':\n          e.preventDefault();\n          items[items.length - 1].focus();\n          break;\n          \n        case 'Enter':\n        case ' ':\n          e.preventDefault();\n          // Only expand if not already expanded (prevents closing)\n          if (!items[currentIndex].expanded) {\n            items[currentIndex].click();\n          }\n          break;\n      }\n    });\n  }\n  \n  _closeOtherItems(selectedItem) {\n    if (!this.shadowRoot) return;\n    const items = Array.from(this.shadowRoot.querySelectorAll('collapsible-item'));\n    const selectedIndex = items.indexOf(selectedItem);\n    \n    // Update our internal state\n    this._lastOpenedIndex = selectedIndex;\n    this._currentOpenItem = selectedItem;\n    \n    // Close all other items\n    items.forEach(item => {\n      if (item !== selectedItem) {\n        item.expanded = false;\n      }\n    });\n    \n    // Ensure the selected item is expanded\n    if (selectedItem) {\n      selectedItem.expanded = true;\n      this.dispatchEvent(new CustomEvent('item-selected', {\n        detail: { index: selectedIndex, item: selectedItem },\n        bubbles: true,\n        composed: true\n      }));\n    }\n  }\n  \n  _hasExpandedItem() {\n    if (!this.shadowRoot) return false;\n    const items = this.shadowRoot.querySelectorAll('collapsible-item');\n    return Array.from(items).some(item => item && item.expanded);\n  }\n  \n  _setFirstItemExpanded() {\n    // Use requestAnimationFrame to ensure the shadow DOM is ready\n    requestAnimationFrame(() => {\n      const items = this.shadowRoot?.querySelectorAll('collapsible-item');\n      if (items && items.length > 0) {\n        // Only set first item as expanded if no item is currently open\n        if (this._lastOpenedIndex === -1) {\n          items[0].expanded = true;\n          this._currentOpenItem = items[0];\n          this._lastOpenedIndex = 0;\n        }\n      }\n    });\n  }\n  \n  _handleItemClick(e) {\n    // Stop any immediate propagation to prevent other handlers\n    e.stopImmediatePropagation();\n    \n    const targetItem = e.target.closest('collapsible-item');\n    if (!targetItem) return false;\n    \n    // Prevent default to take full control of the toggle behavior\n    e.preventDefault();\n    \n    // If clicking the currently open item, do nothing (keep it open)\n    if (targetItem === this._currentOpenItem) {\n      return false;\n    }\n    \n    // For other items, close all others and open the clicked one\n    this._closeOtherItems(targetItem);\n    \n    // Ensure the target item is expanded\n    targetItem.expanded = true;\n    \n    // Update our internal state\n    const items = Array.from(this.shadowRoot.querySelectorAll('collapsible-item'));\n    this._currentOpenItem = targetItem;\n    this._lastOpenedIndex = items.indexOf(targetItem);\n    \n    // Dispatch item-selected event\n    this.dispatchEvent(new CustomEvent('item-selected', {\n      detail: { \n        index: this._lastOpenedIndex,\n        item: targetItem \n      },\n      bubbles: true,\n      composed: true\n    }));\n    \n    return false;\n  }\n  \n  /**\n   * Sets up intersection observer for lazy loading\n   * @private\n   */\n  _setupIntersectionObserver() {\n    // Not needed anymore since we're preloading all images\n    // But kept for backward compatibility\n    if (this._intersectionObserver) {\n      this._intersectionObserver.disconnect();\n      this._intersectionObserver = null;\n    }\n  }\n  \n  _observeItems() {\n    // Not needed anymore since we're preloading all images\n    // But kept for backward compatibility\n  }\n  \n  disconnectedCallback() {\n    // Clean up event listeners\n    const items = Array.from(this.shadowRoot.querySelectorAll('collapsible-item'));\n    items.forEach(item => {\n      item.removeEventListener('click', this._handleItemClick);\n      item.removeEventListener('toggle', this._handleToggle);\n    });\n    \n    // Disconnect observers\n    if (this._mutationObserver) {\n      this._mutationObserver.disconnect();\n      this._mutationObserver = null;\n    }\n    \n    if (this._intersectionObserver) {\n      this._intersectionObserver.disconnect();\n      this._intersectionObserver = null;\n    }\n  }\n  \n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === 'images' && oldValue !== newValue) {\n      this.images = newValue;\n    }\n  }\n  \n  _setupEventListeners() {\n    const items = Array.from(this.shadowRoot.querySelectorAll('collapsible-item'));\n    \n    items.forEach((item, index) => {\n      // Remove any existing click handlers to prevent duplicates\n      item.removeEventListener('click', this._handleItemClick);\n      item.removeEventListener('keydown', this._handleKeyDown);\n      item.removeEventListener('toggle', this._handleToggle);\n      \n      // Store a reference to the original click handler\n      if (!item._originalClickHandler) {\n        item._originalClickHandler = item._onClick;\n      }\n      \n      // Override the click handler to prevent closing the open item\n      item._onClick = (e) => {\n        if (item === this._currentOpenItem) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          return false;\n        }\n        return item._originalClickHandler?.call(item, e);\n      };\n      \n      // Add our custom handlers\n      item.addEventListener('click', this._handleItemClick, { capture: true });\n      item.addEventListener('keydown', this._handleKeyDown, { capture: true });\n      item.addEventListener('toggle', this._handleToggle, { capture: true });\n      \n      // Make items keyboard accessible\n      item.setAttribute('tabindex', '0');\n      item.setAttribute('role', 'button');\n    });\n    \n    this._hasRendered = true;\n  }\n  \n  _setupMutationObserver() {\n    // Set up mutation observer to watch for changes in the DOM\n    this._mutationObserver = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.type === 'childList') {\n          // If items were added or removed, update event listeners\n          this._setupEventListeners();\n        }\n      });\n    });\n    \n    // Start observing the shadow root for changes\n    this._mutationObserver.observe(this.shadowRoot, {\n      childList: true,\n      subtree: true\n    });\n  }\n  \n  _handleToggle(e) {\n    // We don't need to handle the toggle event directly anymore\n    // as we're handling everything in _handleItemClick\n    e.stopPropagation();\n    \n    // Prevent the default toggle behavior since we're handling it in _handleItemClick\n    e.preventDefault();\n    return false;\n  }\n  \n  _handleKeyDown(e) {\n    // Handle keyboard navigation (Enter or Space to toggle)\n    if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault();\n      this._handleItemClick(e);\n    }\n    // Handle arrow keys for navigation\n    else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {\n      e.preventDefault();\n      const items = Array.from(this.shadowRoot.querySelectorAll('collapsible-item'));\n      const currentIndex = items.indexOf(e.target);\n      let nextIndex;\n      \n      if (e.key === 'ArrowDown') {\n        nextIndex = (currentIndex + 1) % items.length;\n      } else {\n        nextIndex = (currentIndex - 1 + items.length) % items.length;\n      }\n      \n      const nextItem = items[nextIndex];\n      if (nextItem) {\n        nextItem.focus();\n        nextItem.click();\n      }\n    }\n  }\n  \n  // Public method to get the index of the currently open item\n  getOpenItemIndex() {\n    return this._lastOpenedIndex;\n  }\n\n  // Public method to open a specific item by index\n  _closeOtherItems(selectedItem) {\n    if (!this.shadowRoot) return;\n    \n    const items = Array.from(this.shadowRoot.querySelectorAll('collapsible-item'));\n    const selectedIndex = items.indexOf(selectedItem);\n    \n    // If clicking the currently open item, do nothing\n    if (selectedItem === this._currentOpenItem) {\n      // Force the item to stay open\n      if (!selectedItem.expanded) {\n        selectedItem.expanded = true;\n      }\n      return;\n    }\n    \n    // Close all items except the selected one\n    items.forEach((item, index) => {\n      if (index !== selectedIndex) {\n        item.expanded = false;\n      } else {\n        // Ensure the selected item is expanded\n        item.expanded = true;\n        this._currentOpenItem = item;\n        this._lastOpenedIndex = selectedIndex;\n      }\n    });\n    \n    // Dispatch item-selected event\n    this.dispatchEvent(new CustomEvent('item-selected', {\n      detail: { index: selectedIndex, item: selectedItem },\n      bubbles: true,\n      composed: true\n    }));\n  }\n  \n  /**\n   * Forces preloading of all images\n   * @public\n   */\n  preloadAllImages() {\n    if (!this._images || !Array.isArray(this._images)) return;\n    \n    console.log('Preloading all images:', this._images.length);\n    \n    // Load all images in sequence with a small delay to prevent UI blocking\n    this._images.forEach((img, index) => {\n      if (img && img.src) {\n        // Small delay to prevent UI blocking\n        setTimeout(() => {\n          if (!this._preloadedImages.has(img.src) || \n              this._preloadedImages.get(img.src).status === 'error') {\n            this._loadImage(img, index, false);\n          }\n        }, index * 50); // 50ms delay between each image load\n      }\n    });\n  }\n  \n  /**\n   * Gets the preload status of an image\n   * @param {number} index - Index of the image\n   * @returns {string} - Status of the image ('loading', 'loaded', 'error', or undefined if not found)\n   * @public\n   */\n  getImageStatus(index) {\n    if (!this._images || !this._images[index] || !this._images[index].src) {\n      return undefined;\n    }\n    const status = this._preloadedImages.get(this._images[index].src);\n    return status ? status.status : undefined;\n  }\n  \n  // Public method to open a specific item by index\n  openItem(index) {\n    if (!this.shadowRoot) return;\n    \n    const items = Array.from(this.shadowRoot.querySelectorAll('collapsible-item'));\n    if (index >= 0 && index < items.length) {\n      // If clicking the currently open item, do nothing\n      if (items[index] === this._currentOpenItem) {\n        return;\n      }\n      \n      // Close all items first\n      items.forEach(item => {\n        item.expanded = false;\n      });\n      \n      // Open the selected item\n      items[index].expanded = true;\n      this._currentOpenItem = items[index];\n      this._lastOpenedIndex = index;\n      \n      // Dispatch event\n      this.dispatchEvent(new CustomEvent('item-selected', {\n        detail: { \n          index: index,\n          item: items[index]\n        },\n        bubbles: true,\n        composed: true\n      }));\n    }\n  }\n\n  /**\n   * Preloads all images in the collection\n   * @param {number} [priorityIndex] - Optional index to load first\n   */\n  _preloadImages(priorityIndex = null) {\n    if (!this._images || !Array.isArray(this._images)) return;\n    \n    // If we have a priority index, load it first\n    if (priorityIndex !== null && this._images[priorityIndex]) {\n      this._loadImage(this._images[priorityIndex], priorityIndex, true);\n    }\n    \n    // Then load all other images\n    this._images.forEach((img, index) => {\n      // Skip the priority index if it was already loaded\n      if (priorityIndex !== null && index === priorityIndex) return;\n      \n      // Only load if not already loaded or loading\n      const imgSrc = img.src;\n      if (!this._preloadedImages.has(imgSrc) || this._preloadedImages.get(imgSrc).status === 'error') {\n        this._loadImage(img, index, false);\n      }\n    });\n  }\n\n  /**\n   * Loads a single image\n   * @private\n   */\n  _loadImage(imageData, index, isPriority = false) {\n    if (!imageData || !imageData.src) {\n      console.warn('No image data or src provided');\n      return;\n    }\n    \n    let imgSrc = imageData.src;\n    \n    // Ensure absolute URL for local files\n    if (!imgSrc.startsWith('http') && !imgSrc.startsWith('data:') && !imgSrc.startsWith('/')) {\n      imgSrc = `/${imgSrc}`;\n    }\n    \n    console.log(`Attempting to load image [${index}]: ${imgSrc}`, { isPriority });\n    \n    // Skip if already loaded or loading, unless it's a priority load\n    if (this._preloadedImages.has(imgSrc)) {\n      const status = this._preloadedImages.get(imgSrc).status;\n      if ((status === 'loaded' || status === 'loading') && !isPriority) {\n        console.log(`Image already ${status}: ${imgSrc}`);\n        return;\n      }\n    }\n    \n    // Mark as loading\n    this._preloadedImages.set(imgSrc, { status: 'loading' });\n    \n    // Create a transparent 1x1 pixel data URL as initial src to prevent broken image icon\n    const transparentPixel = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n    this._updateImageInDOM(imgSrc, transparentPixel, false);\n    \n    const img = new Image();\n    \n    // Set up loading state\n    img.onload = () => {\n      console.log(`Image loaded successfully: ${imgSrc}`);\n      this._preloadedImages.set(imgSrc, { \n        status: 'loaded',\n        element: img,\n        width: img.width,\n        height: img.height\n      });\n      \n      // Update the image in the DOM with the actual image\n      this._updateImageInDOM(imgSrc, imgSrc);\n    };\n    \n    img.onerror = (e) => {\n      console.error(`Error loading image: ${imgSrc}`, e);\n      this._preloadedImages.set(imgSrc, { \n        status: 'error',\n        error: e \n      });\n      \n      // Show error state in the DOM without showing broken image icon\n      this._updateImageInDOM(imgSrc, transparentPixel, true);\n    };\n    \n    // Start loading the actual image\n    img.src = imgSrc;\n  }\n  \n  /**\n   * Updates an image in the DOM when it's loaded\n   * @private\n   */\n  _updateImageInDOM(src, newSrc, isError = false) {\n    if (!this.shadowRoot) {\n      console.warn('No shadow root available');\n      return;\n    }\n    \n    console.log(`Updating image in DOM: ${src}`, { newSrc, isError });\n    \n    // First, try to find by exact data-index match if we have it\n    let images = [];\n    const allImages = Array.from(this.shadowRoot.querySelectorAll('img[data-src]'));\n    \n    // Try exact match first\n    images = allImages.filter(img => {\n      const dataSrc = img.getAttribute('data-src');\n      return dataSrc && (dataSrc === src || dataSrc.endsWith(`/${src}`) || dataSrc.endsWith(src));\n    });\n    \n    // If not found, try with just the filename\n    if (images.length === 0) {\n      const filename = src.split('/').pop();\n      images = allImages.filter(img => {\n        const dataSrc = img.getAttribute('data-src');\n        return dataSrc && dataSrc.endsWith(filename);\n      });\n      console.log(`Trying to find by filename ${filename}, found:`, images.length);\n    }\n    \n    // If still not found, try any image that contains the filename\n    if (images.length === 0) {\n      const filename = src.split('/').pop();\n      images = allImages.filter(img => {\n        const dataSrc = img.getAttribute('data-src');\n        return dataSrc && dataSrc.includes(filename);\n      });\n      console.log(`Trying to find by partial filename ${filename}, found:`, images.length);\n    }\n    \n    // If still not found, try to find by index\n    if (images.length === 0) {\n      const allImagesWithIndex = Array.from(this.shadowRoot.querySelectorAll('img'));\n      const index = this._images.findIndex(img => img && img.src === src);\n      if (index >= 0 && index < allImagesWithIndex.length) {\n        images = [allImagesWithIndex[index]];\n      }\n    }\n    \n    // If no images found, try to find by src attribute directly\n    if (images.length === 0) {\n      images = Array.from(this.shadowRoot.querySelectorAll(`img[src=\"${src}\"]`));\n    }\n    \n    // Get the image info to check if it's an initial load\n    const imageInfo = this._preloadedImages.get(src);\n    const isInitialLoad = this._isInitialLoad && (!imageInfo || imageInfo.isInitialLoad !== false);\n    \n    images.forEach(img => {\n      if (isError) {\n        // Add error class and set a placeholder\n        img.classList.add('image-error');\n        img.alt = 'Failed to load image';\n        img.classList.remove('loading');\n      } else if (newSrc) {\n        console.log(`Updating image source: ${newSrc}`, { isInitialLoad });\n        \n        // Update the image source\n        img.src = newSrc;\n        img.removeAttribute('data-src');\n        \n        // For initial load, use opacity transition\n        if (isInitialLoad) {\n          // Let CSS handle the opacity transition\n          img.classList.add('loaded');\n          \n          // Mark this image as no longer in initial load\n          if (imageInfo) {\n            imageInfo.isInitialLoad = false;\n          }\n        } else {\n          // For subsequent loads, use height animation\n          const container = img.closest('.image-container');\n          if (container) {\n            const startHeight = container.offsetHeight;\n            container.style.height = `${startHeight}px`;\n            container.style.transition = 'height 0.3s ease-in-out';\n            \n            // Force reflow to ensure the transition works\n            void container.offsetHeight;\n            \n            // Set final height\n            container.style.height = 'auto';\n            const endHeight = container.offsetHeight;\n            container.style.height = `${startHeight}px`;\n            \n            // Animate to final height\n            requestAnimationFrame(() => {\n              img.classList.add('loaded');\n              container.style.height = `${endHeight}px`;\n            });\n            \n            // Clean up after animation\n            container.addEventListener('transitionend', function onEnd() {\n              container.style.height = '';\n              container.style.transition = '';\n              container.removeEventListener('transitionend', onEnd);\n            });\n          } else {\n            img.classList.add('loaded');\n          }\n        }\n      }\n      \n      // Remove the loader if it exists\n      const loader = img.nextElementSibling;\n      if (loader && loader.classList.contains('image-loader')) {\n        loader.remove();\n      }\n    });\n  }\n  \n  _render() {\n    if (!this.shadowRoot) return;\n    \n    // Save the current open index before re-rendering\n    const previousOpenIndex = this._lastOpenedIndex;\n    const isInitialRender = !this._hasRendered;\n    const noAnimation = this.hasAttribute('no-animation');\n    \n    // Create the styles\n    const style = `\n      <style>\n        .image-collection {\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n          max-width: 100%;\n          margin: 0 auto;\n        }\n        \n        .image-container {\n          position: relative;\n          width: 100%;\n          height: 300px;\n          min-height: 300px;\n          overflow: hidden;\n          contain: content;\n          will-change: height;\n        }\n        \n        .image-collection__image {\n          width: 100%;\n          height: 100%;\n          object-fit: cover;\n          transition: opacity 0.3s ease-in-out, height 0.3s ease-in-out;\n          opacity: 0;\n        }\n        \n        :host([no-animation]) .image-collection__image {\n          opacity: 1;\n          transition: none;\n        }\n        \n        /* Initial load - use opacity transition */\n        .initial-load .image-container {\n          height: 300px !important;\n          transition: none !important;\n        }\n        \n        .initial-load .image-collection__image {\n          height: 100%;\n          opacity: 0;\n          transition: opacity 0.3s ease-in-out;\n        }\n        \n        .initial-load .image-collection__image.loaded {\n          opacity: 1;\n        }\n        \n        /* Subsequent loads - use height transition */\n        .image-collection__image.loaded {\n          opacity: 1;\n          height: 100%;\n        }\n        \n        .image-collection__image.image-error {\n          opacity: 1;\n          background-color: #f5f5f5;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          color: #999;\n          font-style: italic;\n        }\n        \n        .image-loader {\n          position: absolute;\n          top: 0;\n          left: 0;\n          right: 0;\n          bottom: 0;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          color: #999;\n          font-style: italic;\n        }\n        \n        .image-collection__image.loaded + .image-loader {\n          display: none;\n        }\n        \n        .image-collection__title {\n          margin: 0;\n          padding: 0.8rem 1rem;\n          color: #333;\n          font-size: 0.8em;\n          font-weight: 600;\n          background: rgba(0,0,0,0.4);\n          color: white;\n          transition: all 0.2s ease;\n          position: relative;\n          z-index: 1;\n          line-height: 1.2;\n          border: none;\n          display: block;\n          width: 100%;\n          text-align: left;\n          color: white;\n          position: absolute;\n          top: 0;\n        }\n\n        \n        collapsible-item {\n          cursor: pointer;\n          transition: background-color 0.2s;\n          border: none;\n          margin: 0;\n          padding: 0;\n          overflow: hidden;\n          display: block;\n          min-height: 45px;\n          position: relative;\n        }\n        \n        collapsible-item:not(:last-child) .image-collection__title {\n          border-bottom: 1px solid rgba(0, 0, 0, 0.05);\n        }\n        \n        @keyframes fadeIn {\n          from { opacity: 0.3; }\n          to { opacity: 1; }\n        }\n      </style>\n    `;\n    \n    // Create the HTML for each image item\n    const items = this._images.map((image, index) => {\n      // Ensure the image path is correct - prepend public path if it's a relative path\n      let imageSrc = image.src;\n      if (imageSrc && !imageSrc.startsWith('http') && !imageSrc.startsWith('data:')) {\n        // Ensure there's exactly one leading slash\n        imageSrc = imageSrc.startsWith('/') ? imageSrc : `/${imageSrc}`;\n      }\n      \n      // Check if image is already loaded\n      const isLoaded = this._preloadedImages.has(imageSrc) && \n                      this._preloadedImages.get(imageSrc).status === 'loaded';\n      const isLoading = this._preloadedImages.has(imageSrc) && \n                       this._preloadedImages.get(imageSrc).status === 'loading';\n      \n      const imgClasses = ['image-collection__image'];\n      if (isLoaded) {\n        imgClasses.push('loaded');\n      } else if (isLoading) {\n        imgClasses.push('loading');\n      }\n      \n      return `\n        <collapsible-item hide-icon data-index=\"${index}\">\n          <div class=\"image-container\">\n            <img\n              ${isLoaded ? `src=\"${imageSrc}\"` : `src=\"\" data-src=\"${imageSrc}\"`}\n              alt=\"${image.alt || image.title || 'Image'}\"\n              class=\"${imgClasses.join(' ')}\"\n              loading=\"lazy\"\n              onerror=\"this.onerror=null;this.classList.add('image-error');\"\n            />\n            ${!isLoaded ? '<div class=\"image-loader\">Loading...</div>' : ''}\n          </div>\n          <div slot=\"header\" class=\"image-collection__title\">${image.title || `Image ${index + 1}`}</div>\n          ${image.description ? `<div slot=\"content\">${image.description}</div>` : ''}\n        </collapsible-item>\n      `;\n    }).join('');\n    \n    // Combine everything into the final template\n    const template = `\n      ${style}\n      <div class=\"image-collection\">\n        <collapsible-list>\n          ${items}\n        </collapsible-list>\n      </div>\n    `;\n    \n    // Set the inner HTML\n    this.shadowRoot.innerHTML = template;\n    \n    // Set initial height for all containers on initial render\n    if (isInitialRender) {\n      const containers = this.shadowRoot.querySelectorAll('.image-container');\n      containers.forEach(container => {\n        container.style.height = '300px';\n      });\n    }\n    \n    // Set up intersection observer for lazy loading\n    if (!this._intersectionObserver) {\n      this._setupIntersectionObserver();\n    }\n    \n    // Setup event listeners\n    this._setupEventListeners();\n    \n    // Restore the previously open item if it exists\n    if (previousOpenIndex >= 0) {\n      this.openItem(previousOpenIndex);\n    } else if (this._images.length > 0) {\n      // Otherwise, open the first item by default\n      this.openItem(0);\n    }\n    \n    // Start loading visible images\n    this._preloadImages();\n    \n    // Mark as rendered\n    this._hasRendered = true;\n    \n    // Load components and setup event listeners\n    return Promise.all([\n      customElements.get('collapsible-list') || \n        import('../../molecules/collapsible-list/CollapsibleList.js'),\n      customElements.get('collapsible-item') || \n        import('../../atoms/collapsible-item/CollapsibleItem.js')\n    ]).then(() => {\n      this._setupEventListeners();\n      \n      // After components are loaded and event listeners are set up\n      const items = Array.from(this.shadowRoot.querySelectorAll('collapsible-item'));\n      \n      if (items.length > 0) {\n        // If we had an item open before, try to restore its state\n        if (previousOpenIndex !== -1 && previousOpenIndex < items.length) {\n          items[previousOpenIndex].expanded = true;\n          this._currentOpenItem = items[previousOpenIndex];\n          this._lastOpenedIndex = previousOpenIndex;\n        } \n        // If this is the first render and we have images, open the first one\n        else if (isInitialRender && this._images.length > 0 && previousOpenIndex === -1) {\n          this._lastOpenedIndex = 0;\n          \n          // If no-animation is set, immediately update the DOM without transitions\n          if (noAnimation) {\n            const items = this.shadowRoot.querySelectorAll('collapsible-item');\n            if (items.length > 0) {\n              items[0].expanded = true;\n              this._currentOpenItem = items[0];\n            }\n          }\n        }\n      }\n      \n      this._hasRendered = true;\n    });\n  }\n}\n\n// Define the custom element\nif (!customElements.get('image-collection')) {\n  customElements.define('image-collection', ImageCollection);\n}\n","/**\n * ProductLayout\n * A layout component that displays an image collection, title, and content\n */\n// Import the image-collection component\nimport '../../organisms/image-collection/ImageCollection';\n\nexport class ProductLayout extends HTMLElement {\n  static get observedAttributes() {\n    return ['title', 'images'];\n  }\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this._title = '';\n    this._images = [];\n    this._isConnected = false;\n    this._hasRendered = false;\n    this._isUpdating = false; // Flag to prevent re-entrant calls\n    this._elements = null;\n    this._render = this._render.bind(this);\n  }\n\n  get title() {\n    return this._title;\n  }\n\n  set title(value) {\n    const newValue = value || '';\n    if (this._title !== newValue) {\n      this._title = newValue;\n      if (this._isConnected) {\n        this._updateTitle();\n      }\n    }\n  }\n\n  get images() {\n    return this._images;\n  }\n\n  set images(value) {\n    let newImages = [];\n    \n    if (typeof value === 'string') {\n      try {\n        newImages = value ? JSON.parse(value) : [];\n      } catch (e) {\n        console.error('Invalid images data format', e);\n        newImages = [];\n      }\n    } else if (Array.isArray(value)) {\n      newImages = [...value];\n    }\n    \n    // Only update if the images have actually changed\n    const imagesChanged = JSON.stringify(this._images) !== JSON.stringify(newImages);\n    this._images = newImages;\n    \n    if (imagesChanged && this._isConnected) {\n      this._updateImages();\n    }\n  }\n\n  connectedCallback() {\n    if (this._isConnected) return;\n    this._isConnected = true;\n    \n    // Initialize from attributes\n    if (this.hasAttribute('title')) {\n      this._title = this.getAttribute('title');\n    }\n    \n    if (this.hasAttribute('images')) {\n      try {\n        this._images = JSON.parse(this.getAttribute('images') || '[]');\n      } catch (e) {\n        console.error('Invalid initial images data', e);\n        this._images = [];\n      }\n    }\n    \n    this._render();\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (oldValue === newValue) return;\n    \n    switch (name) {\n      case 'title':\n        this.title = newValue;\n        break;\n      case 'images':\n        this.images = newValue;\n        break;\n    }\n  }\n\n  _renderImageCollection() {\n    if (!this._images || this._images.length === 0) return '';\n    \n    // Ensure images is an array\n    const images = Array.isArray(this._images) ? this._images : [];\n    \n    // Create an image-collection element with the images and no-animation attribute\n    return `\n      <div>\n        <image-collection \n          images='${JSON.stringify(images)}'\n          style=\"--image-height: 400px;\"\n          no-animation\n        ></image-collection>\n      </div>\n    `;\n  }\n\n  // Cache DOM elements after first render\n  _cacheElements() {\n    if (!this.shadowRoot) return;\n    \n    this._elements = {\n      title: this.shadowRoot.querySelector('.header h2'),\n      imageContainer: this.shadowRoot.querySelector('.image-collection-container'),\n      header: this.shadowRoot.querySelector('.header'),\n      content: this.shadowRoot.querySelector('.content')\n    };\n  }\n\n  _updateTitle() {\n    if (!this.shadowRoot) return;\n    \n    if (this._elements?.title) {\n      this._elements.title.textContent = this._title;\n    } else if (this._isConnected) {\n      this._render();\n    }\n  }\n\n  _updateImages() {\n    if (this._isUpdating || !this.shadowRoot || !this._isConnected) return;\n    \n    this._isUpdating = true;\n    try {\n      const imageCollection = this.shadowRoot.querySelector('image-collection');\n      if (imageCollection) {\n        // Update existing image collection\n        const currentImages = imageCollection.getAttribute('images');\n        const newImages = JSON.stringify(this._images);\n        if (currentImages !== newImages) {\n          imageCollection.setAttribute('images', newImages);\n        }\n      } else if (this._elements?.imageContainer) {\n        // Re-render just the image container if it exists\n        this._elements.imageContainer.innerHTML = this._renderImageCollection();\n      } else if (!this._hasRendered) {\n        // Only do full render if we haven't rendered yet\n        this._render();\n      }\n    } finally {\n      this._isUpdating = false;\n    }\n  }\n\n  _render() {\n    if (this._isUpdating || !this.shadowRoot || !this._isConnected) return;\n    \n    this._isUpdating = true;\n    try {\n      // Only set innerHTML on first render\n      if (!this._hasRendered) {\n      this.shadowRoot.innerHTML = `\n      <style>\n        :host {\n          display: block;\n          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n          --primary-color: #00f0ff;\n          --text-color: #e0e0e0;\n          --text-secondary: #8f9bb3;\n          --border-color: #2a2a3a;\n          --bg-color: #1a1a2e;\n        }\n        \n        \n        .image-collection-container {\n          width: 100%;\n          position: relative;\n          border-radius: 8px;\n          background-color: #1a1a1a;\n          margin-bottom: 0;\n          overflow: hidden;\n        }\n        \n        .header {\n          padding: 1rem 0;\n        }\n        \n        .header h2 {\n          margin: 0;\n          color: var(--text-color);\n          font-size: 1.5rem;\n          font-weight: 600;\n        }\n        \n        .divider {\n          border: none;\n          height: 1px;\n          background-color: white;\n          margin: 0;\n        }\n        \n        .content {\n          padding: 0;\n          color: var(--text-secondary);\n          line-height: 1.6;\n        }\n        \n        ::slotted(.vehicle-description) {\n          color: var(--text-secondary);\n          line-height: 1.7;\n        }\n        \n        ::slotted(.vehicle-specs) {\n          margin-top: 1.5rem;\n          background: rgba(0, 0, 0, 0.2);\n          border-radius: 8px;\n          padding: 1.5rem;\n          border: 1px solid var(--border-color);\n        }\n        \n        ::slotted(.vehicle-specs h3) {\n          color: var(--primary-color);\n          margin-top: 0;\n          margin-bottom: 1.25rem;\n          font-size: 1.25rem;\n          font-weight: 600;\n          border-bottom: 1px solid var(--border-color);\n          padding-bottom: 0.75rem;\n        }\n        \n        ::slotted(.vehicle-specs ul) {\n          list-style: none;\n          padding: 0;\n          margin: 0;\n          display: grid;\n          grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));\n          gap: 0.75rem;\n        }\n        \n        ::slotted(.vehicle-specs li) {\n          padding: 0.75rem 1rem;\n          background: rgba(0, 0, 0, 0.2);\n          border-radius: 6px;\n          border-left: 3px solid var(--primary-color);\n          transition: var(--transition, all 0.3s ease);\n        }\n        \n        ::slotted(.vehicle-specs li:hover) {\n          background: rgba(0, 240, 255, 0.1);\n          transform: translateX(4px);\n        }\n        \n        ::slotted(.vehicle-specs strong) {\n          color: var(--primary-color);\n          margin-right: 0.5rem;\n          font-weight: 500;\n        }\n      </style>\n      <div class=\"product-layout\">\n        ${this._images.length > 0 ? `\n          <div class=\"image-collection-container\">\n            ${this._renderImageCollection()}\n          </div>\n        ` : ''}\n        \n        <div class=\"header\">\n          <div class=\"divider\"></div>\n          <h2>${this._title}</h2>\n        </div>\n        \n        <div class=\"content\">\n          <slot name=\"content\"></slot>\n        </div>\n      </div>`;\n      \n        this._hasRendered = true;\n        this._cacheElements();\n      } else if (!this._isUpdating) {\n        // On subsequent renders, only update what's needed\n        this._updateTitle();\n        this._updateImages();\n      }\n    } finally {\n      this._isUpdating = false;\n    }\n  }\n}\n\n// Auto-register the component when loaded directly\nif (typeof window !== 'undefined' && !customElements.get('product-layout')) {\n  customElements.define('product-layout', ProductLayout);\n}\n"],"names":["CollapsibleList","HTMLElement","observedAttributes","constructor","super","this","attachShadow","mode","_isUpdating","_handleItemToggle","bind","container","document","createElement","slot","style","textContent","appendChild","shadowRoot","append","connectedCallback","_initialized","_initializeComponent","_updateReverseHeading","addEventListener","hasAttribute","_ensureOneItemExpanded","_setupMutationObserver","setAttribute","_observer","MutationObserver","async","mutations","shouldUpdate","mutation","type","attributeName","node","addedNodes","nodeType","Node","ELEMENT_NODE","matches","observe","attributes","attributeFilter","childList","subtree","isReversed","getAttribute","disconnect","processItems","items","item","removeAttribute","nestedItems","querySelectorAll","length","Array","from","nestedLists","processLists","lists","list","offsetHeight","error","e","target","parentElement","expanded","_closeOtherItems","exceptItem","closest","forEach","_getOpenItems","firstItem","querySelector","customElements","get","define","CollapsibleItem","_isExpanded","_nestedList","_showToggle","_handleHeaderClick","_handleKeyDown","isExpanded","_nestedContent","display","_updateToggleVisibility","_updateAriaExpanded","_toggleElement","classList","add","remove","innerHTML","content","className","_headerElement","toggleContainer","_headerSlot","name","headerContent","_defaultSlot","stopPropagation","toggle","event","join","preventDefault","key","isNoChildren","marginLeft","paddingLeft","hasNestedItems","children","toString","value","Boolean","overflow","height","startHeight","requestAnimationFrame","transition","setTimeout","_dispatchEvents","force","shouldExpand","dispatchEvent","CustomEvent","detail","bubbles","composed","eventType","header","_a","_b","flexDirection","margin","attributeChangedCallback","oldValue","newValue","additionalComponents","loadAdditionalComponents","selectionMenuModule","Promise","resolve","then","SelectionMenu$1","SelectionMenu","default","productLayoutModule","ProductLayout$1","ProductLayout","getAdditionalComponents","wrappers","Object","entries","webComponents","componentName","webComponent","ReactComponent","forwardRef","props","ref","elementRef","useRef","eventHandlers","useEffect","element","current","currentEventHandlers","startsWith","eventName","substring","toLowerCase","handler","removeEventListener","elementProps","reduce","acc","TagName","is","displayName","VuePlugin","install","app","tagName","vueComponent","inheritAttrs","emits","render","attrs","$attrs","replace","g","toUpperCase","on","keys","$listeners","$createElement","$slots","component","Components","load","assign","window","catch","console","_selectedId","_data","_blockEventsOnParent","_reverseHeading","setupEventListeners","data","JSON","parse","setSelectedItem","blockEventsOnParent","reverseHeading","renderItems","level","map","hasChildren","isSelected","id","menuList","getElementById","_boundHandleClick","handleItemClick","itemId","itemData","_findItemById","customEvent","found","prevSelected","newSelected","isArray","ImageCollection","_images","_hasRendered","_handleItemClick","_handleToggle","_currentOpenItem","_lastOpenedIndex","_mutationObserver","_intersectionObserver","_preloadedImages","Map","_visibleIndices","Set","_preloadDistance","_isInitialLoad","images","_preloadImages","_render","img","_addEventListeners","preloadAllImages","_hasExpandedItem","_setFirstItemExpanded","index","indexOf","currentIndex","findIndex","activeElement","focus","click","selectedItem","selectedIndex","some","stopImmediatePropagation","targetItem","_setupIntersectionObserver","_observeItems","disconnectedCallback","_setupEventListeners","_originalClickHandler","_onClick","call","capture","nextIndex","nextItem","getOpenItemIndex","src","has","status","_loadImage","getImageStatus","openItem","priorityIndex","imgSrc","imageData","isPriority","set","transparentPixel","_updateImageInDOM","Image","onload","width","onerror","newSrc","isError","allImages","filter","dataSrc","endsWith","filename","split","pop","includes","allImagesWithIndex","imageInfo","isInitialLoad","alt","endHeight","onEnd","loader","nextElementSibling","contains","previousOpenIndex","isInitialRender","noAnimation","template","image","imageSrc","isLoaded","isLoading","imgClasses","push","title","description","all","CollapsibleList$1","CollapsibleItem$1","_title","_isConnected","_elements","_updateTitle","newImages","imagesChanged","stringify","_updateImages","_renderImageCollection","_cacheElements","imageContainer","imageCollection","currentImages"],"mappings":"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"}